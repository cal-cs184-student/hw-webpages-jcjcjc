<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Jessica Ng, Carolann Dong</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-jcjcjc/">https://cal-cs184-student.github.io/hw-webpages-jcjcjc/</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-jcjcjc">https://github.com/cal-cs184-student/hw1-rasterizer-jcjcjc</a>

		<!-- <figure>
			<img src="images/image1.png" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure> -->

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>

		<ol>
			<li>To rasterize triangles, we first found the coordinates of the corners of the bounding box of our triangle, ensuring that these corner coordinates fall within our viewport. For every pixel in that bounding box, we sample the center of that pixel. We determined whether the sample point lies inside the triangle using the three line tests and line equations shown in lecture 2. If the point is inside or on a boundary/edge of the triangle, then we filled that pixel in with the given color.</li>
			<li>Our algorithm is no worse than one that checks each sample within the bounding box of the triangle, since that is exactly what our algorithm does.</li>
			<li>The following is a screenshot of basic/test4.svg.</li>
		</ol>
		<figure>
			<img src="task1ss.png" alt="task1ss" style="width:50%"/>
		</figure>

		<!-- <p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/image1.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/image2.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="images/image3.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/image4.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div> -->
		
		<h2>Task 2: Antialiasing by Supersampling</h2>

		To implement supersampling, we modified the rasterizer to keep track of a separate sample buffer that stores multiple color samples per pixel instead of a single color. The size of this buffer scales linearly with the sampling rate. Conceptually, each pixel is divided into a grid of subpixels, and each subpixel stores its own color value.
		During rasterization, instead of only looking at the pixel center, we loop over all subsample locations inside each pixel. For each sample point within the pixel, we perform the standard inside-triangle test and compute its color if it lies inside the triangle. That color is written into the corresponding location in the sample buffer. Finally, we resolve the final framebuffer by averaging the subpixel colors within each pixel and writing that average as the final pixel color.
		Supersampling is useful because it reduces aliasing artifacts, especially along edges. With only one sample at the pixel center, a pixel is treated as either fully inside or fully outside a triangle, which produces jaggies. By taking multiple samples per pixel, we approximate the fraction of the pixel covered by the triangle. Pixels along edges take on an intermediate color, which creates smoother transitions along boundaries.
		In terms of rasterization pipeline changes, we modified the rasterization stage to iterate over multiple sample points within a pixel instead of a single center sample, added a larger sample buffer data structure, and added a final resolve step that downsamples the sample buffer into the framebuffer.
		
		<div style="display: flex; flex-direction: row; justify-content: center; align-items: flex-start; gap: 10px;">
		<figure style="text-align: center; margin: 0; flex: 1;">
			<img src="task2pic1.png" alt="task2pic1" style="width: 100%; display: block; margin: 0 auto;"/>
			<figcaption>Sampling rate: 1</figcaption>
		</figure>
		<figure style="text-align: center; margin: 0; flex: 1;">
			<img src="task2pic4.png" alt="task2pic4" style="width: 100%; display: block; margin: 0 auto;"/>
			<figcaption>Sampling rate: 4</figcaption>
		</figure>
		<figure style="text-align: center; margin: 0; flex: 1;">
			<img src="task2pic16.png" alt="task2pic16" style="width: 100%; display: block; margin: 0 auto;"/>
			<figcaption>Sampling rate: 16</figcaption>
		</figure>
	</div>


		As sampling rate increases, edges look significantly smoother and the triangle tip looks less jagged. This occurs because higher sampling rates capture partial pixel coverage more accurately, reducing aliasing artifacts along sharp geometric edges by introducing intermediate pixel values.

		<h2>Task 3: Transforms</h2>
		Cubeman is doing the splits! We rotated and translated the rectangles that form Cubeman's legs to make him a gymnast.
		<figure>
			<img src="task3ss.png" alt="task3ss" style="width:50%"/>
		</figure>

		For extra credit, we added a viewport rotation feature to the GUI. Clicking "J" will rotate the viewport 5 degrees clockwise, and clicking "K" will rotate the viewport 5 degrees counterclockwise. Clicking the space key will reset to the original viewport with no rotation.
		<figure>
			<img src="task3ec.png" alt="task3ec" style="width:50%"/>
		</figure>
		To implement this feature, we inserted a rotation transform into the SVG-to-screen matrix stack. To rotate around the scene's center rather than the top left, the logical transformation steps are: translate SVG center to origin, rotate, translate back, convert SVG to NDC, and then convert NDC to screen. In code, the matrix transformation chain is "backwards" since matrix multiplication is carried out from right to left.
		
		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		<ol>
			<li>Level sampling is choosing which resolution of a texture to sample from based on how big that texture appears on screen. If a textured triangle is very small or far away, sampling from the full-resolution image causes aliasing and generally looks bad, so we instead sample from a lower-resolution mip level. We precompute the mip maps at each level to speed up render time, even though we sacrifice some memory to store all texture levels.
			To choose the mip map level, we first estimated how much the uv coordinates change across one pixel by comparing the uv values at (x, y), (x+1, y), and (x, y+1) in barycentric coordinates. We used those distances to compute the scale factor L and took log base 2 to get the appropriate mip level D. 
			We implemented two methods: picking the nearest mip level by rounding D and linearly interpolating between two mip levels by taking a weighted average, also called trilinear texture filtering.
			</li>
			<li>
				Let's discuss the tradeoffs between speed, memory usage, and antialiasing power between pixel sampling, level sampling, and number of samples per pixel.
				<ul>
					<li>
						<b>Pixel sampling: </b> Nearest pixel sampling is slightly faster than bilinear since it only takes 1 lookup versus 4 lookups + interpolation. Neither requires extra memory. Bilinear sampling generally outputs a smoother and less blocky graphic, and is more helpful in antialiasing when textures are magnified.
					</li>
					<li>
						<b>Level sampling: </b> Level sampling is slightly slower than no mipmapping due to a couple of extra math computations but this is not a significant speed tradeoff. Level sampling requires more memory usage due to the storing of multiple precomputed mip map texture levels. Level sampling has strong antialiasing power, especially when it comes to minified textures. 
					</li>
					<li>
						<b>Number of samples per pixel: </b> The runtime cost of supersampling increases linearly with the number of subsamples we take per pixel. The sample buffer size also grows proportionally with the number of subsamples per pixel, incurring high memory usage. Overall, supersampling has strong antialiasing powers, significantly reducing visual artifacts such as jaggies along geometric edges.
					</li>
				</ul>
			</li>
		</ol>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lzeropnearest.png" width="400px"/>
				  <figcaption>L_ZERO and P_NEAREST</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lzeropbilinear.png" width="400px"/>
				  <figcaption>L_ZERO and P_LINEAR</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lnearestpnearest.png" width="400px"/>
				  <figcaption>L_NEAREST and P_NEAREST</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lnearestpbilinear.png" width="400px"/>
				  <figcaption>L_NEAREST and P_LINEAR</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<!-- <h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. -->

		<!-- <h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul> -->
		</div>
	</body>
</html>